======================
How to Extend Prest
======================
:Author: Mark Nodine
:Contact: mnodine@alum.mit.edu
:Revision: $Revision: 762 $
:Date: $Date: 2006-01-27 11:47:47 -0600 (Fri, 27 Jan 2006) $
:Copyright: This document has been placed in the public domain.

.. perl::
   # Make path safe for -T
   use PrestConfig;
   my $perl_dir = $1 if $PrestConfig::SAFE_PERL =~ m|^(.*)/perl|;
   $ENV{PATH} = "$perl_dir:/bin";

.. contents::

This document explains how to write new modules to extend prest.  There
are two principal mechanisms by which prest can be extended: adding new
plug-in directives and adding new writers.  For either of these tasks,
the programmer should be familiar with the DOM_ data structure and the
`DOM.pm`_ subroutines.

.. _`DOM`: prest_internals.html#dom
.. _`DOM.pm`: prest_internals.html#dom-pm

Adding New Directives
---------------------

To add a plug-in directive, the programmer should be familiar with the
RST::Directive:: routines starting with `RST::Directive::arg_check`_,
as well as the RST:: routines `RST::system_message`_ and
`RST::Paragraph`_.

.. _`RST::Directive::arg_check`: prest_internals.html#rstdirectivearg-check
.. _`RST::system_message`: prest_internals.html#rstsystem-message
.. _`RST::Paragraph`: prest_internals.html#rstparagraph

A plug-in directive can be added by creating a Perl module with the
same name as the directive (with a ".pm" extension, of course).  The
Perl module must have a BEGIN block which registers the routine to
call to process the directive using
`RST::Directive::handle_directive`_.

.. _`RST::Directive::handle_directive`: 
   prest_internals.html#rstdirectivehandle-directive

As an example from the ``if`` plug-in directive,

.. system:: perl -ne 'print if /^BEGIN/ .. /^\}/' .\./.\./bin/Directive/if.pm
   :literal:

Whatever routine you designate will get called with the following
arguments:

  *``$name``*:
    The directive name.  This argument is useful if you use the same
    routine to process more than one directive with different names.
  *``$parent``*:
    Pointer to the parent DOM object.  It is needed to add new DOM objects
    to the parent's contents.
  *``$source``*:
    A string indicating the source for the directive.  If you call
    `RST::Paragraphs`_ to parse reStructuredText recursively, you
    should supply it a source like "$name directive at $source, line $lineno".
  *``$lineno``*:
    The line number indicating where in the source this directive
    appears. 
  *``$dtext``*:
    The directive text in a format suitable for parsing by
    `RST::Directive::parse_directive`_.  It consists of only the
    arguments, options, and content sections.
  *``$lit``*:
    The complete literal text of the explicit markup containing the
    directive.  Used for generating error messages.

.. _`RST::Paragraphs`: prest_internals.html#rstparagraphs
.. _`RST::Directive::parse_directive`:
   prest_internals.html#rstdirectiveparse-directive 

The directive's routine will return any DOM objects representing system
messages.  It will also likely produce side-effects by appending new
DOM objects to the parent object's contents.

The first thing the directive's routine will usually do is to call
`RST::Directive::parse_directive`_ as follows:

.. system:: grep parse_directive .\./.\./bin/Directive/if.pm
   :literal:

It is recommended that if the directive encounters any parse errors
(wrong number of arguments, does/does not contain content, etc.), that
it return a system_message DOM object formatted with
`RST::Directive::system_message`_ to label the message as having come
from the specific directive.

.. _`RST::Directive::system_message`: 
   prest_internals.html#rstdirectivesystem-message

It is also up to the package to provide the documentation that appears
when the user runs ``prest -h``.  Any comment in the perl module within
a ``=begin Description`` .. ``=end Description`` section of a Perl POD
section is printed for the module's help.  For example, here is the
help documentation from the ``if`` directive:

.. system:: perl -ne 'print if /^=pod/ .. /^=cut/' .\./.\./bin/Directive/if.pm
   :literal:

.. note::

   The help text should parse correctly as reStructuredText, since it
   is passed through prest to create the web documentation.

Adding New Writers
------------------

The output from a writer is generated by traversing the DOM_ tree
recursively.  There can be multiple phases of traversal, and the value
produced by the top-level DOM object in the final phase is what
actually gets written to the output.

Each writer exists in a file that is the writer's name with the
extension ``.wrt``.  A ``.wrt`` file has a special write schema
format specifically designed to make development of writers easy.
Here is a BNF for the _`write schema` file format::

  parser := phase_list
  phase_list := phase_desc | phase_list phase_desc
  phase_desc := phase id eq '{' NL sub_list NL '}' NL
  phase := 'phase' |
  eq := '=' |
  sub_list := sub_desc | sub_list sub_desc
  sub_desc := sub id eq '{' NL perl_code NL '}' NL
  sub := 'sub' |

An ``id`` is any sequence of non-space characters.  ``NL`` is a newline.
``perl_code`` is the perl code for a subroutine.  Note that the words
"phase" and "sub" are optional, as is the equal sign ("=") between the
``id`` and the open brace. 

The id's associated with phases are arbitrary.  The phases are
executed in the order they appear in the file. [#]_ The names of the
subroutines are regular expressions to match the ``tag`` field in the
DOM_ structure.  The first subroutine in the phase whose regular
expression matches the ``tag`` field of the DOM object to be processed
is the one that is called, and is referred to as the handler for that
tag.  The handlers are called doing a post-order traversal of the
tree; in other words, once all of the children (members of the
``content`` field) of a DOM object have had their handler called,
the DOM's own handler is called.  The arguments of the subroutine are:

  ``$dom``:
    A reference to the DOM object being processed.
  ``$str``:
    The concatenation of the strings returned by the handlers of all
    the children of the DOM object being processed.

The subroutine needs to return a string that is the combined result of
processing all the layers from the DOM on down (assisted, of course,
by the ``$str`` argument).  The result returned by the subroutine gets
cached in the ``val`` field of the DOM object for future use, as well
as being propagated as part of the ``$str`` argument of the parent's
handler routine.

Options to the writer can be specified using a -W define, which has
the format ::

  -W var[=val]

If no value is supplied, then the value defaults to 1.  Any such
defines become available to the writer directly in a variable ``$var``.

As an example, here is the code for the dom writer:

.. system:: perl -ne 'print if /^phase/ .. 0' .\./.\./bin/dom.wrt
   :literal:

This example is perhaps not typical, since it needs to call the
internal `main::ProcessDOM`_ routine in order to process the DOM
objects in the internal ``.details`` field of the DOM; most writers
should have no need to do so.

.. _`main::ProcessDom`: prest_internals.html#mainprocessdom

It is also up to the writer to provide the documentation that appears
when the user runs ``prest -h``.  Any comment in the writer appearing
in a POD (Perl's Plain-Old-Documentation) Description section is
printed for the writer's help.  For example, here is the help
documentation from the ``dom`` writer:

.. system:: perl -ne 'print if /^=pod/ .. /^=cut/' .\./.\./bin/dom.wrt
   :literal:

.. note::

   The help text should parse correctly as reStructuredText, since it
   is passed through prest to create the web documentation.

Footnotes
---------

.. [#] If the same phase name is repeated later in the file, its
   subroutine definitions are appended to those of the phase and
   run at the earlier position.

..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
