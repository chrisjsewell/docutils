<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>A Record of reStructuredText Syntax Alternatives</title>
<meta name="author" content="David Goodger" />
<meta name="date" content="2006-01-26 10:53:09 -0600 (Thu, 26 Jan 2006)" />
<link rel="stylesheet" href="default.css" type="text/css" />
</head>
<body>
<div class="document" id="a-record-of-restructuredtext-syntax-alternatives">
<h1 class="title">A Record of reStructuredText Syntax Alternatives</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name" />
<col class="docinfo-content" />
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>David Goodger</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference" href="mailto:goodger&#64;users.sourceforge.net">goodger&#64;users.sourceforge.net</a></td></tr>
<tr><th class="docinfo-name">Revision:</th>
<td>1.2</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>2006-01-26 10:53:09 -0600 (Thu, 26 Jan 2006)</td></tr>
</tbody>
</table>
<p>The following are ideas, alternatives, and justifications that were
considered for reStructuredText syntax, which did not originate with
<a class="reference" href="http://docutils.sourceforge.net/mirror/setext.html">Setext</a> or <a class="reference" href="http://dev.zope.org/Members/jim/StructuredTextWiki/FrontPage">StructuredText</a>.  For an analysis of constructs which <em>did</em>
originate with StructuredText or Setext, please see <a class="reference" href="problems.html">Problems With
StructuredText</a>.  See the <a class="reference" href="reStructuredText.html">reStructuredText Markup Specification</a>
for full details of the established syntax.</p>
<div class="contents topic" id="contents">
<p class="topic-title first"><a name="contents">Contents</a></p>
<ul class="simple">
<li><a class="reference" href="#or-not-to-do" id="id6" name="id6">... Or Not To Do?</a><ul class="simple">
<li><a class="reference" href="#compound-enumerated-lists" id="id7" name="id7">Compound Enumerated Lists</a></li>
<li><a class="reference" href="#sloppy-indentation-of-list-items" id="id8" name="id8">Sloppy Indentation of List Items</a></li>
<li><a class="reference" href="#lazy-indentation-of-list-items" id="id9" name="id9">Lazy Indentation of List Items</a><ul class="simple">
<li><a class="reference" href="#david-s-idea-for-lazy-indentation" id="id10" name="id10">David's Idea for Lazy Indentation</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference" href="#field-lists" id="id11" name="id11">Field Lists</a></li>
<li><a class="reference" href="#interpreted-text-roles" id="id12" name="id12">Interpreted Text "Roles"</a></li>
<li><a class="reference" href="#comments" id="id13" name="id13">Comments</a></li>
<li><a class="reference" href="#anonymous-hyperlinks" id="id14" name="id14">Anonymous Hyperlinks</a></li>
<li><a class="reference" href="#reworking-explicit-markup" id="id15" name="id15">Reworking Explicit Markup</a></li>
<li><a class="reference" href="#backquotes-in-phrase-links" id="id16" name="id16">Backquotes in Phrase-Links</a></li>
<li><a class="reference" href="#substitution-mechanism" id="id17" name="id17">Substitution Mechanism</a></li>
<li><a class="reference" href="#reworking-footnotes" id="id18" name="id18">Reworking Footnotes</a></li>
<li><a class="reference" href="#auto-enumerated-lists" id="id19" name="id19">Auto-Enumerated Lists</a></li>
<li><a class="reference" href="#inline-external-targets" id="id20" name="id20">Inline External Targets</a></li>
<li><a class="reference" href="#doctree-representation-of-transitions" id="id21" name="id21">Doctree Representation of Transitions</a></li>
</ul>
</div>
<div class="section" id="or-not-to-do">
<h1><a class="toc-backref" href="#id6" name="or-not-to-do">... Or Not To Do?</a></h1>
<p>This is the realm of the possible but questionably probable.  These
ideas are kept here as a record of what has been proposed, for
posterity and in case any of them prove to be useful.</p>
<div class="section" id="compound-enumerated-lists">
<h2><a class="toc-backref" href="#id7" name="compound-enumerated-lists">Compound Enumerated Lists</a></h2>
<p>Allow for compound enumerators, such as "1.1." or "1.a." or "1(a)", to
allow for nested enumerated lists without indentation?</p>
</div>
<div class="section" id="sloppy-indentation-of-list-items">
<h2><a class="toc-backref" href="#id8" name="sloppy-indentation-of-list-items">Sloppy Indentation of List Items</a></h2>
<p>Perhaps the indentation shouldn't be so strict.  Currently, this is
required:</p>
<pre class="literal-block">1. First line,
   second line.
</pre>
<p>Anything wrong with this?</p>
<pre class="literal-block">1. First line,
 second line.
</pre>
<p>Problem?</p>
<pre class="literal-block">1. First para.

   Block quote.  (no good: requires some indent relative to first
   para)

 Second Para.

2. Have to carefully define where the literal block ends::

     Literal block

   Literal block?
</pre>
<p>Hmm...  Non-strict indentation isn't such a good idea.</p>
</div>
<div class="section" id="lazy-indentation-of-list-items">
<h2><a class="toc-backref" href="#id9" name="lazy-indentation-of-list-items">Lazy Indentation of List Items</a></h2>
<p>Another approach: Going back to the first draft of reStructuredText
(2000-11-27 post to Doc-SIG):</p>
<pre class="literal-block">- This is the fourth item of the main list (no blank line above).
The second line of this item is not indented relative to the
bullet, which precludes it from having a second paragraph.
</pre>
<p>Change that to <em>require</em> a blank line above and below, to reduce
ambiguity.  This "loosening" may be added later, once the parser's
been nailed down.  However, a serious drawback of this approach is to
limit the content of each list item to a single paragraph.</p>
<div class="section" id="david-s-idea-for-lazy-indentation">
<h3><a class="toc-backref" href="#id10" name="david-s-idea-for-lazy-indentation">David's Idea for Lazy Indentation</a></h3>
<p>Consider a paragraph in a word processor.  It is a single logical line
of text which ends with a newline, soft-wrapped arbitrarily at the
right edge of the page or screen.  We can think of a plaintext
paragraph in the same way, as a single logical line of text, ending
with two newlines (a blank line) instead of one, and which may contain
arbitrary line breaks (newlines) where it was accidentally
hard-wrapped by an application.  We can compensate for the accidental
hard-wrapping by "unwrapping" every unindented second and subsequent
line.  The indentation of the first line of a paragraph or list item
would determine the indentation for the entire element.  Blank lines
would be required between list items when using lazy indentation.</p>
<p>The following example shows the lazy indentation of multiple body
elements:</p>
<pre class="literal-block">- This is the first paragraph
of the first list item.

  Here is the second paragraph
of the first list item.

- This is the first paragraph
of the second list item.

  Here is the second paragraph
of the second list item.
</pre>
<p>A more complex example shows the limitations of lazy indentation:</p>
<pre class="literal-block">- This is the first paragraph
of the first list item.

  Next is a definition list item:

  Term
      Definition.  The indentation of the term is
required, as is the indentation of the definition's
first line.

      When the definition extends to more than
one line, lazy indentation may occur.  (This is the second
paragraph of the definition.)

- This is the first paragraph
of the second list item.

  - Here is the first paragraph of
the first item of a nested list.

  So this paragraph would be outside of the nested list,
but inside the second list item of the outer list.

But this paragraph is not part of the list at all.
</pre>
<p>And the ambiguity remains:</p>
<pre class="literal-block">- Look at the hyphen at the beginning of the next line
- is it a second list item marker, or a dash in the text?

Similarly, we may want to refer to numbers inside enumerated
lists:

1. How many socks in a pair? There are
2. How many pants in a pair? Exactly
1. Go figure.
</pre>
<p>Literal blocks and block quotes would still require consistent
indentation for all their lines.  For block quotes, we might be able
to get away with only requiring that the first line of each contained
element be indented.  For example:</p>
<pre class="literal-block">Here's a paragraph.

    This is a paragraph inside a block quote.
Second and subsequent lines need not be indented at all.

    - A bullet list inside
the block quote.

      Second paragraph of the
bullet list inside the block quote.
</pre>
<p>Although feasible, this form of lazy indentation has problems.  The
document structure and hierarchy is not obvious from the indentation,
making the source plaintext difficult to read.  This will also make
keeping track of the indentation while writing difficult and
error-prone.  However, these problems may be acceptable for Wikis and
email mode, where we may be able to rely on less complex structure
(few nested lists, for example).</p>
</div>
</div>
</div>
<div class="section" id="field-lists">
<h1><a class="toc-backref" href="#id11" name="field-lists">Field Lists</a></h1>
<p>Prior to the syntax for field lists being finalized, several
alternatives were proposed.</p>
<ol class="arabic">
<li><p class="first">Unadorned <a class="reference" href="http://www.rfc-editor.org/rfc/rfc822.txt">RFC822</a> everywhere:</p>
<pre class="literal-block">Author: Me
Version: 1
</pre>
<p>Advantages: clean, precedent (RFC822-compliant).  Disadvantage:
ambiguous (these paragraphs are a prime example).</p>
<p>Conclusion: rejected.</p>
</li>
<li><p class="first">Special case: use unadorned <a class="reference" href="http://www.rfc-editor.org/rfc/rfc822.txt">RFC822</a> for the very first or very last
text block of a document:</p>
<pre class="literal-block">"""
Author: Me
Version: 1

The rest of the document...
"""
</pre>
<p>Advantages: clean, precedent (RFC822-compliant).  Disadvantages:
special case, flat (unnested) field lists only, still ambiguous:</p>
<pre class="literal-block">"""
Usage: cmdname [options] arg1 arg2 ...

We obviously *don't* want the like above to be interpreted as a
field list item.  Or do we?
"""
</pre>
<p>Conclusion: rejected for the general case, accepted for specific
contexts (PEPs, email).</p>
</li>
<li><p class="first">Use a directive:</p>
<pre class="literal-block">.. fields::

   Author: Me
   Version: 1
</pre>
<p>Advantages: explicit and unambiguous, RFC822-compliant.
Disadvantage: cumbersome.</p>
<p>Conclusion: rejected for the general case (but such a directive
could certainly be written).</p>
</li>
<li><p class="first">Use Javadoc-style:</p>
<pre class="literal-block">&#64;Author: Me
&#64;Version: 1
&#64;param a: integer
</pre>
<p>Advantages: unambiguous, precedent, flexible.  Disadvantages:
non-intuitive, ugly, not RFC822-compliant.</p>
<p>Conclusion: rejected.</p>
</li>
<li><p class="first">Use leading colons:</p>
<pre class="literal-block">:Author: Me
:Version: 1
</pre>
<p>Advantages: unambiguous, obvious (<em>almost</em> RFC822-compliant),
flexible, perhaps even elegant.  Disadvantages: no precedent, not
quite RFC822-compliant.</p>
<p>Conclusion: accepted!</p>
</li>
<li><p class="first">Use double colons:</p>
<pre class="literal-block">Author:: Me
Version:: 1
</pre>
<p>Advantages: unambiguous, obvious? (<em>almost</em> RFC822-compliant),
flexible, similar to syntax already used for literal blocks and
directives.  Disadvantages: no precedent, not quite
RFC822-compliant, similar to syntax already used for literal blocks
and directives.</p>
<p>Conclusion: rejected because of the syntax similarity &amp; conflicts.</p>
</li>
</ol>
<p>Why is RFC822 compliance important?  It's a universal Internet
standard, and super obvious.  Also, I'd like to support the PEP format
(ulterior motive: get PEPs to use reStructuredText as their standard).
But it <em>would</em> be easy to get used to an alternative (easy even to
convert PEPs; probably harder to convert python-deviants ;-).</p>
<p>Unfortunately, without well-defined context (such as in email headers:
RFC822 only applies before any blank lines), the RFC822 format is
ambiguous.  It is very common in ordinary text.  To implement field
lists unambiguously, we need explicit syntax.</p>
<p>The following question was posed in a footnote:</p>
<blockquote>
<p>Should "bibliographic field lists" be defined at the parser level,
or at the DPS transformation level?  In other words, are they
reStructuredText-specific, or would they also be applicable to
another (many/every other?) syntax?</p>
</blockquote>
<p>The answer is that bibliographic fields are a
reStructuredText-specific markup convention.  Other syntaxes may
implement the bibliographic elements explicitly.  For example, there
would be no need for such a transformation for an XML-based markup
syntax.</p>
</div>
<div class="section" id="interpreted-text-roles">
<h1><a class="toc-backref" href="#id12" name="interpreted-text-roles">Interpreted Text "Roles"</a></h1>
<p>The original purpose of interpreted text was as a mechanism for
descriptive markup, to describe the nature or role of a word or
phrase.  For example, in XML we could say "&lt;function&gt;len&lt;/function&gt;"
to mark up "len" as a function.  It is envisaged that within Python
docstrings (inline documentation in Python module source files, the
primary market for reStructuredText) the role of a piece of
interpreted text can be inferred implicitly from the context of the
docstring within the program source.  For other applications, however,
the role may have to be indicated explicitly.</p>
<p>Interpreted text is enclosed in single backquotes (`).</p>
<ol class="arabic">
<li><p class="first">Initially, it was proposed that an explicit role could be indicated
as a word or phrase within the enclosing backquotes:</p>
<ul>
<li><p class="first">As a prefix, separated by a colon and whitespace:</p>
<pre class="literal-block">`role: interpreted text`
</pre>
</li>
<li><p class="first">As a suffix, separated by whitespace and a colon:</p>
<pre class="literal-block">`interpreted text :role`
</pre>
</li>
</ul>
<p>There are problems with the initial approach:</p>
<ul class="simple">
<li>There could be ambiguity with interpreted text containing colons.
For example, an index entry of "Mission: Impossible" would
require a backslash-escaped colon.</li>
<li>The explicit role is descriptive markup, not content, and will
not be visible in the processed output.  Putting it inside the
backquotes doesn't feel right; the <em>role</em> isn't being quoted.</li>
</ul>
</li>
<li><p class="first">Tony Ibbs suggested that the role be placed outside the
backquotes:</p>
<pre class="literal-block">role:`prefix` or `suffix`:role
</pre>
<p>This removes the embedded-colons ambiguity, but limits the role
identifier to be a single word (whitespace would be illegal).
Since roles are not meant to be visible after processing, the lack
of whitespace support is not important.</p>
<p>The suggested syntax remains ambiguous with respect to ratios and
some writing styles.  For example, suppose there is a "signal"
identifier, and we write:</p>
<pre class="literal-block">...calculate the `signal`:noise ratio.
</pre>
<p>"noise" looks like a role.</p>
</li>
<li><p class="first">As an improvement on #2, we can bracket the role with colons:</p>
<pre class="literal-block">:role:`prefix` or `suffix`:role:
</pre>
<p>This syntax is similar to that of field lists, which is fine since
both are doing similar things: describing.</p>
<p>This is the syntax chosen for reStructuredText.</p>
</li>
<li><p class="first">Another alternative is two colons instead of one:</p>
<pre class="literal-block">role::`prefix` or `suffix`::role
</pre>
<p>But this is used for analogies ("A:B::C:D": "A is to B as C is to
D").</p>
<p>Both alternative #2 and #4 lack delimiters on both sides of the
role, making it difficult to parse (by the reader).</p>
</li>
<li><p class="first">Some kind of bracketing could be used:</p>
<ul>
<li><p class="first">Parentheses:</p>
<pre class="literal-block">(role)`prefix` or `suffix`(role)
</pre>
</li>
<li><p class="first">Braces:</p>
<pre class="literal-block">{role}`prefix` or `suffix`{role}
</pre>
</li>
<li><p class="first">Square brackets:</p>
<pre class="literal-block">[role]`prefix` or `suffix`[role]
</pre>
</li>
<li><p class="first">Angle brackets:</p>
<pre class="literal-block">&lt;role&gt;`prefix` or `suffix`&lt;role&gt;
</pre>
<p>(The overlap of *ML tags with angle brackets would be too
confusing and precludes their use.)</p>
</li>
</ul>
</li>
</ol>
<p>Syntax #3 was chosen for reStructuredText.</p>
</div>
<div class="section" id="comments">
<h1><a class="toc-backref" href="#id13" name="comments">Comments</a></h1>
<p>A problem with comments (actually, with all indented constructs) is
that they cannot be followed by an indented block -- a block quote --
without swallowing it up.</p>
<p>I thought that perhaps comments should be one-liners only.  But would
this mean that footnotes, hyperlink targets, and directives must then
also be one-liners?  Not a good solution.</p>
<p>Tony Ibbs suggested a "comment" directive.  I added that we could
limit a comment to a single text block, and that a "multi-block
comment" could use "comment-start" and "comment-end" directives.  This
would remove the indentation incompatibility.  A "comment" directive
automatically suggests "footnote" and (hyperlink) "target" directives
as well.  This could go on forever!  Bad choice.</p>
<p>Garth Kidd suggested that an "empty comment", a ".." explicit markup
start with nothing on the first line (except possibly whitespace) and
a blank line immediately following, could serve as an "unindent".  An
empty comment does <strong>not</strong> swallow up indented blocks following it,
so block quotes are safe.  "A tiny but practical wart."  Accepted.</p>
</div>
<div class="section" id="anonymous-hyperlinks">
<h1><a class="toc-backref" href="#id14" name="anonymous-hyperlinks">Anonymous Hyperlinks</a></h1>
<p>Alan Jaffray came up with this idea, along with the following syntax:</p>
<pre class="literal-block">Search the `Python DOC-SIG mailing list archives`{}_.

.. _: http://mail.python.org/pipermail/doc-sig/
</pre>
<p>The idea is sound and useful.  I suggested a "double underscore"
syntax:</p>
<pre class="literal-block">Search the `Python DOC-SIG mailing list archives`__.

.. __: http://mail.python.org/pipermail/doc-sig/
</pre>
<p>But perhaps single underscores are okay?  The syntax looks better, but
the hyperlink itself doesn't explicitly say "anonymous":</p>
<pre class="literal-block">Search the `Python DOC-SIG mailing list archives`_.

.. _: http://mail.python.org/pipermail/doc-sig/
</pre>
<p>Mixing anonymous and named hyperlinks becomes confusing.  The order of
targets is not significant for named hyperlinks, but it is for
anonymous hyperlinks:</p>
<pre class="literal-block">Hyperlinks: anonymous_, named_, and another anonymous_.

.. _named: named
.. _: anonymous1
.. _: anonymous2
</pre>
<p>Without the extra syntax of double underscores, determining which
hyperlink references are anonymous may be difficult.  We'd have to
check which references don't have corresponding targets, and match
those up with anonymous targets.  Keeping to a simple consistent
ordering (as with auto-numbered footnotes) seems simplest.</p>
<p>reStructuredText will use the explicit double-underscore syntax for
anonymous hyperlinks.  An alternative (see <a class="reference" href="#reworking-explicit-markup">Reworking Explicit
Markup</a> below) for the somewhat awkward ".. __:" syntax is "__":</p>
<pre class="literal-block">An anonymous__ reference.

__ http://anonymous
</pre>
</div>
<div class="section" id="reworking-explicit-markup">
<h1><a class="toc-backref" href="#id15" name="reworking-explicit-markup">Reworking Explicit Markup</a></h1>
<p>Alan Jaffray came up with the idea of <a class="reference" href="#anonymous-hyperlinks">anonymous hyperlinks</a>, added
to reStructuredText.  Subsequently it was asserted that hyperlinks
(especially anonymous hyperlinks) would play an increasingly important
role in reStructuredText documents, and therefore they require a
simpler and more concise syntax.  This prompted a review of the
current and proposed explicit markup syntaxes with regards to
improving usability.</p>
<ol class="arabic">
<li><p class="first">Original syntax:</p>
<pre class="literal-block">.. _blah:                     internal hyperlink target
.. _blah: http://somewhere    external hyperlink target
.. _blah: blahblah_           indirect hyperlink target
.. __:                        anonymous internal target
.. __: http://somewhere       anonymous external target
.. __: blahblah_              anonymous indirect target
.. [blah] http://somewhere    footnote
.. blah:: http://somewhere    directive
.. blah: http://somewhere     comment
</pre>
<div class="note">
<p class="first admonition-title">Note</p>
<p class="last">The comment text was intentionally made to look like a hyperlink
target.</p>
</div>
<p>Origins:</p>
<ul class="simple">
<li>Except for the colon (a delimiter necessary to allow for
phrase-links), hyperlink target <tt class="docutils literal"><span class="pre">..</span> <span class="pre">_blah:</span></tt> comes from Setext.</li>
<li>Comment syntax from Setext.</li>
<li>Footnote syntax from StructuredText ("named links").</li>
<li>Directives and anonymous hyperlinks original to reStructuredText.</li>
</ul>
<p>Advantages:</p>
<ul class="simple">
<li>Consistent explicit markup indicator: "..".</li>
<li>Consistent hyperlink syntax: ".. _" &amp; ":".</li>
</ul>
<p>Disadvantages:</p>
<ul class="simple">
<li>Anonymous target markup is awkward: ".. __:".</li>
<li>The explicit markup indicator ("..") is excessively overloaded?</li>
<li>Comment text is limited (can't look like a footnote, hyperlink,
or directive).  But this is probably not important.</li>
</ul>
</li>
<li><p class="first">Alan Jaffray's proposed syntax #1:</p>
<pre class="literal-block">__ _blah                      internal hyperlink target
__ blah: http://somewhere     external hyperlink target
__ blah: blahblah_            indirect hyperlink target
__                            anonymous internal target
__ http://somewhere           anonymous external target
__ blahblah_                  anonymous indirect target
__ [blah] http://somewhere    footnote
.. blah:: http://somewhere    directive
.. blah: http://somewhere     comment
</pre>
<p>The hyperlink-connoted underscores have become first-level syntax.</p>
<p>Advantages:</p>
<ul class="simple">
<li>Anonymous targets are simpler.</li>
<li>All hyperlink targets are one character shorter.</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li><p class="first">Inconsistent internal hyperlink targets.  Unlike all other named
hyperlink targets, there's no colon.  There's an extra leading
underscore, but we can't drop it because without it, "blah" looks
like a relative URI.  Unless we restore the colon:</p>
<pre class="literal-block">__ blah:                      internal hyperlink target
</pre>
</li>
<li><p class="first">Obtrusive markup?</p>
</li>
</ul>
</li>
<li><p class="first">Alan Jaffray's proposed syntax #2:</p>
<pre class="literal-block">.. _blah                      internal hyperlink target
.. blah: http://somewhere     external hyperlink target
.. blah: blahblah_            indirect hyperlink target
..                            anonymous internal target
.. http://somewhere           anonymous external target
.. blahblah_                  anonymous indirect target
.. [blah] http://somewhere    footnote
!! blah: http://somewhere     directive
## blah: http://somewhere     comment
</pre>
<p>Leading underscores have been (almost) replaced by "..", while
comments and directives have gained their own syntax.</p>
<p>Advantages:</p>
<ul class="simple">
<li>Anonymous hyperlinks are simpler.</li>
<li>Unique syntax for comments.  Connotation of "comment" from
some programming languages (including our favorite).</li>
<li>Unique syntax for directives.  Connotation of "action!".</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li><p class="first">Inconsistent internal hyperlink targets.  Again, unlike all other
named hyperlink targets, there's no colon.  There's a leading
underscore, matching the trailing underscores of references,
which no other hyperlink targets have.  We can't drop that one
leading underscore though: without it, "blah" looks like a
relative URI.  Again, unless we restore the colon:</p>
<pre class="literal-block">.. blah:                      internal hyperlink target
</pre>
</li>
<li><p class="first">All (except for internal) hyperlink targets lack their leading
underscores, losing the "hyperlink" connotation.</p>
</li>
<li><p class="first">Obtrusive syntax for comments.  Alternatives:</p>
<pre class="literal-block">;; blah: http://somewhere
   (also comment syntax in Lisp &amp; others)
,, blah: http://somewhere
   ("comma comma": sounds like "comment"!)
</pre>
</li>
<li><p class="first">Iffy syntax for directives.  Alternatives?</p>
</li>
</ul>
</li>
<li><p class="first">Tony Ibbs' proposed syntax:</p>
<pre class="literal-block">.. _blah:                     internal hyperlink target
.. _blah: http://somewhere    external hyperlink target
.. _blah: blahblah_           indirect hyperlink target
..                            anonymous internal target
.. http://somewhere           anonymous external target
.. blahblah_                  anonymous indirect target
.. [blah] http://somewhere    footnote
.. blah:: http://somewhere    directive
.. blah: http://somewhere     comment
</pre>
<p>This is the same as the current syntax, except for anonymous
targets which drop their "__: ".</p>
<p>Advantage:</p>
<ul class="simple">
<li>Anonymous targets are simpler.</li>
</ul>
<p>Disadvantages:</p>
<ul class="simple">
<li>Anonymous targets lack their leading underscores, losing the
"hyperlink" connotation.</li>
<li>Anonymous targets are almost indistinguishable from comments.
(Better to know "up front".)</li>
</ul>
</li>
<li><p class="first">David Goodger's proposed syntax: Perhaps going back to one of
Alan's earlier suggestions might be the best solution.  How about
simply adding "__ " as a synonym for ".. __: " in the original
syntax?  These would become equivalent:</p>
<pre class="literal-block">.. __:                        anonymous internal target
.. __: http://somewhere       anonymous external target
.. __: blahblah_              anonymous indirect target

__                            anonymous internal target
__ http://somewhere           anonymous external target
__ blahblah_                  anonymous indirect target
</pre>
</li>
</ol>
<p>Alternative 5 has been adopted.</p>
</div>
<div class="section" id="backquotes-in-phrase-links">
<h1><a class="toc-backref" href="#id16" name="backquotes-in-phrase-links">Backquotes in Phrase-Links</a></h1>
<p>[From a 2001-06-05 Doc-SIG post in reply to questions from Doug
Hellmann.]</p>
<p>The first draft of the spec, posted to the Doc-SIG in November 2000,
used square brackets for phrase-links.  I changed my mind because:</p>
<ol class="arabic simple">
<li>In the first draft, I had already decided on single-backquotes for
inline literal text.</li>
<li>However, I wanted to minimize the necessity for backslash escapes,
for example when quoting Python repr-equivalent syntax that uses
backquotes.</li>
<li>The processing of identifiers (function/method/attribute/module
etc. names) into hyperlinks is a useful feature.  PyDoc recognizes
identifiers heuristically, but it doesn't take much imagination to
come up with counter-examples where PyDoc's heuristics would result
in embarassing failure.  I wanted to do it deterministically, and
that called for syntax.  I called this construct "interpreted
text".</li>
<li>Leveraging off the <tt class="docutils literal"><span class="pre">*emphasis*/**strong**</span></tt> syntax, lead to the
idea of using double-backquotes as syntax.</li>
<li>I worked out some rules for inline markup recognition.</li>
<li>In combination with #5, double backquotes lent themselves to inline
literals, neatly satisfying #2, minimizing backslash escapes.  In
fact, the spec says that no interpretation of any kind is done
within double-backquote inline literal text; backslashes do <em>no</em>
escaping within literal text.</li>
<li>Single backquotes are then freed up for interpreted text.</li>
<li>I already had square brackets required for footnote references.</li>
<li>Since interpreted text will typically turn into hyperlinks, it was
a natural fit to use backquotes as the phrase-quoting syntax for
trailing-underscore hyperlinks.</li>
</ol>
<p>The original inspiration for the trailing underscore hyperlink syntax
was Setext.  But for phrases Setext used a very cumbersome
<tt class="docutils literal"><span class="pre">underscores_between_words_like_this_</span></tt> syntax.</p>
<p>The underscores can be viewed as if they were right-pointing arrows:
<tt class="docutils literal"><span class="pre">--&gt;</span></tt>.  So <tt class="docutils literal"><span class="pre">hyperlink_</span></tt> points away from the reference, and
<tt class="docutils literal"><span class="pre">..</span> <span class="pre">_hyperlink:</span></tt> points toward the target.</p>
</div>
<div class="section" id="substitution-mechanism">
<h1><a class="toc-backref" href="#id17" name="substitution-mechanism">Substitution Mechanism</a></h1>
<p>Substitutions arose out of a Doc-SIG thread begun on 2001-10-28 by
Alan Jaffray, "reStructuredText inline markup".  It reminded me of a
missing piece of the reStructuredText puzzle, first referred to in my
contribution to "Documentation markup &amp; processing / PEPs" (Doc-SIG
2001-06-21).</p>
<p>Substitutions allow the power and flexibility of directives to be
shared by inline text.  They are a way to allow arbitrarily complex
inline objects, while keeping the details out of the flow of text.
They are the equivalent of SGML/XML's named entities.  For example, an
inline image (using reference syntax alternative 4d (vertical bars)
and definition alternative 3, the alternatives chosen for inclusion in
the spec):</p>
<pre class="literal-block">The |biohazard| symbol must be used on containers used to dispose
of medical waste.

.. |biohazard| image:: biohazard.png
   [height=20 width=20]
</pre>
<p>The <tt class="docutils literal"><span class="pre">|biohazard|</span></tt> substitution reference will be replaced in-line by
whatever the <tt class="docutils literal"><span class="pre">..</span> <span class="pre">|biohazard|</span></tt> substitution definition generates (in
this case, an image).  A substitution definition contains the
substitution text bracketed with vertical bars, followed by a an
embedded inline-compatible directive, such as "image".  A transform is
required to complete the substitution.</p>
<p>Syntax alternatives for the reference:</p>
<ol class="arabic">
<li><p class="first">Use the existing interpreted text syntax, with a predefined role
such as "sub":</p>
<pre class="literal-block">The `biohazard`:sub: symbol...
</pre>
<p>Advantages: existing syntax, explicit.  Disadvantages: verbose,
obtrusive.</p>
</li>
<li><p class="first">Use a variant of the interpreted text syntax, with a new suffix
akin to the underscore in phrase-link references:</p>
<pre class="literal-block">(a) `name`&#64;
(b) `name`#
(c) `name`&amp;
(d) `name`/
(e) `name`&lt;
(f) `name`::
(g) `name`:
</pre>
<p>Due to incompatibility with other constructs and ordinary text
usage, (f) and (g) are not possible.</p>
</li>
<li><p class="first">Use interpreted text syntax with a fixed internal format:</p>
<pre class="literal-block">(a) `:name:`
(b) `name:`
(c) `name::`
(d) `::name::`
(e) `%name%`
(f) `#name#`
(g) `/name/`
(h) `&amp;name&amp;`
(i) `|name|`
(j) `[name]`
(k) `&lt;name&gt;`
(l) `&amp;name;`
(m) `'name'`
</pre>
<p>To avoid ML confusion (k) and (l) are definitely out.  Square
brackets (j) won't work in the target (the substitution definition
would be indistinguishable from a footnote).</p>
<p>The <tt class="docutils literal"><span class="pre">`/name/`</span></tt> syntax (g) is reminiscent of "s/find/sub"
substitution syntax in ed-like languages.  However, it may have a
misleading association with regexps, and looks like an absolute
POSIX path.  (i) is visually equivalent and lacking the
connotations.</p>
<p>A disadvantage of all of these is that they limit interpreted text,
albeit only slightly.</p>
</li>
<li><p class="first">Use specialized syntax, something new:</p>
<pre class="literal-block">(a) #name#
(b) &#64;name&#64;
(c) /name/
(d) |name|
(e) &lt;&lt;name&gt;&gt;
(f) //name//
(g) ||name||
(h) ^name^
(i) [[name]]
(j) ~name~
(k) !name!
(l) =name=
(m) ?name?
(n) &gt;name&lt;
</pre>
<p>"#" (a) and "&#64;" (b) are obtrusive.  "/" (c) without backquotes
looks just like a POSIX path; it is likely for such usage to appear
in text.</p>
<p>"|" (d) and "^" (h) are feasible.</p>
</li>
<li><p class="first">Redefine the trailing underscore syntax.  See definition syntax
alternative 4, below.</p>
</li>
</ol>
<p>Syntax alternatives for the definition:</p>
<ol class="arabic">
<li><p class="first">Use the existing directive syntax, with a predefined directive such
as "sub".  It contains a further embedded directive resolving to an
inline-compatible object:</p>
<pre class="literal-block">.. sub:: biohazard
   .. image:: biohazard.png
      [height=20 width=20]

.. sub:: parrot
   That bird wouldn't *voom* if you put 10,000,000 volts
   through it!
</pre>
<p>The advantages and disadvantages are the same as in inline
alternative 1.</p>
</li>
<li><p class="first">Use syntax as in #1, but with an embedded directivecompressed:</p>
<pre class="literal-block">.. sub:: biohazard image:: biohazard.png
   [height=20 width=20]
</pre>
<p>This is a bit better than alternative 1, but still too much.</p>
</li>
<li><p class="first">Use a variant of directive syntax, incorporating the substitution
text, obviating the need for a special "sub" directive name.  If we
assume reference alternative 4d (vertical bars), the matching
definition would look like this:</p>
<pre class="literal-block">.. |biohazard| image:: biohazard.png
   [height=20 width=20]
</pre>
</li>
<li><p class="first">(Suggested by Alan Jaffray on Doc-SIG from 2001-11-06.)</p>
<p>Instead of adding new syntax, redefine the trailing underscore
syntax to mean "substitution reference" instead of "hyperlink
reference".  Alan's example:</p>
<pre class="literal-block">I had lunch with Jonathan_ today.  We talked about Zope_.

.. _Jonathan: lj [user=jhl]
.. _Zope: http://www.zope.org/
</pre>
<p>A problem with the proposed syntax is that URIs which look like
simple reference names (alphanum plus ".", "-", "_") would be
indistinguishable from substitution directive names.  A more
consistent syntax would be:</p>
<pre class="literal-block">I had lunch with Jonathan_ today.  We talked about Zope_.

.. _Jonathan: lj:: user=jhl
.. _Zope: http://www.zope.org/
</pre>
<p>(<tt class="docutils literal"><span class="pre">::</span></tt> after <tt class="docutils literal"><span class="pre">..</span> <span class="pre">_Jonathan:</span> <span class="pre">lj</span></tt>.)</p>
<p>The "Zope" target is a simple external hyperlink, but the
"Jonathan" target contains a directive.  Alan proposed is that the
reference text be replaced by whatever the referenced directive
(the "directive target") produces.  A directive reference becomes a
hyperlink reference if the contents of the directive target resolve
to a hyperlink.  If the directive target resolves to an icon, the
reference is replaced by an inline icon.  If the directive target
resolves to a hyperlink, the directive reference becomes a
hyperlink reference.</p>
<p>This seems too indirect and complicated for easy comprehension.</p>
<p>The reference in the text will sometimes become a link, sometimes
not.  Sometimes the reference text will remain, sometimes not.  We
don't know <em>at the reference</em>:</p>
<pre class="literal-block">This is a `hyperlink reference`_; its text will remain.
This is an `inline icon`_; its text will disappear.
</pre>
<p>That's a problem.</p>
</li>
</ol>
<p>The syntax that has been incorporated into the spec and parser is
reference alternative 4d with definition alternative 3:</p>
<pre class="literal-block">The |biohazard| symbol...

.. |biohazard| image:: biohazard.png
   [height=20 width=20]
</pre>
<p>We can also combine substitution references with hyperlink references,
by appending a "_" (named hyperlink reference) or "__" (anonymous
hyperlink reference) suffix to the substitution reference.  This
allows us to click on an image-link:</p>
<pre class="literal-block">The |biohazard|_ symbol...

.. |biohazard| image:: biohazard.png
   [height=20 width=20]
.. _biohazard: http://www.cdc.gov/
</pre>
<p>There have been several suggestions for the naming of these
constructs, originally called "substitution references" and
"substitutions".</p>
<ol class="arabic simple">
<li>Candidate names for the reference construct:<ol class="loweralpha simple">
<li>substitution reference</li>
<li>tagging reference</li>
<li>inline directive reference</li>
<li>directive reference</li>
<li>indirect inline directive reference</li>
<li>inline directive placeholder</li>
<li>inline directive insertion reference</li>
<li>directive insertion reference</li>
<li>insertion reference</li>
<li>directive macro reference</li>
<li>macro reference</li>
<li>substitution directive reference</li>
</ol>
</li>
<li>Candidate names for the definition construct:<ol class="loweralpha simple">
<li>substitution</li>
<li>substitution directive</li>
<li>tag</li>
<li>tagged directive</li>
<li>directive target</li>
<li>inline directive</li>
<li>inline directive definition</li>
<li>referenced directive</li>
<li>indirect directive</li>
<li>indirect directive definition</li>
<li>directive definition</li>
<li>indirect inline directive</li>
<li>named directive definition</li>
<li>inline directive insertion definition</li>
<li>directive insertion definition</li>
<li>insertion definition</li>
<li>insertion directive</li>
<li>substitution definition</li>
<li>directive macro definition</li>
<li>macro definition</li>
<li>substitution directive definition</li>
<li>substitution definition</li>
</ol>
</li>
</ol>
<p>"Inline directive reference" (1c) seems to be an appropriate term at
first, but the term "inline" is redundant in the case of the
reference.  Its counterpart "inline directive definition" (2g) is
awkward, because the directive definition itself is not inline.</p>
<p>"Directive reference" (1d) and "directive definition" (2k) are too
vague.  "Directive definition" could be used to refer to any
directive, not just those used for inline substitutions.</p>
<p>One meaning of the term "macro" (1k, 2s, 2t) is too
programming-language-specific.  Also, macros are typically simple text
substitution mechanisms: the text is substituted first and evaluated
later.  reStructuredText substitution definitions are evaluated in
place at parse time and substituted afterwards.</p>
<p>"Insertion" (1h, 1i, 2n-2q) is almost right, but it implies that
something new is getting added rather than one construct being
replaced by another.</p>
<p>Which brings us back to "substitution".  The overall best names are
"substitution reference" (1a) and "substitution definition" (2v).  A
long way to go to add one word!</p>
</div>
<div class="section" id="reworking-footnotes">
<h1><a class="toc-backref" href="#id18" name="reworking-footnotes">Reworking Footnotes</a></h1>
<p>As a further wrinkle (see <a class="reference" href="#reworking-explicit-markup">Reworking Explicit Markup</a> above), in the
wee hours of 2002-02-28 I posted several ideas for changes to footnote
syntax:</p>
<blockquote>
<ul class="simple">
<li>Change footnote syntax from <tt class="docutils literal"><span class="pre">..</span> <span class="pre">[1]</span></tt> to <tt class="docutils literal"><span class="pre">_[1]</span></tt>? ...</li>
<li>Differentiate (with new DTD elements) author-date "citations"
(<tt class="docutils literal"><span class="pre">[GVR2002]</span></tt>) from numbered footnotes? ...</li>
<li>Render footnote references as superscripts without "[]"? ...</li>
</ul>
</blockquote>
<p>These ideas are all related, and suggest changes in the
reStructuredText syntax as well as the docutils tree model.</p>
<p>The footnote has been used for both true footnotes (asides expanding
on points or defining terms) and for citations (references to external
works).  Rather than dealing with one amalgam construct, we could
separate the current footnote concept into strict footnotes and
citations.  Citations could be interpreted and treated differently
from footnotes.  Footnotes would be limited to numerical labels:
manual ("1") and auto-numbered (anonymous "#", named "#label").</p>
<p>The footnote is the only explicit markup construct (starts with ".. ")
that directly translates to a visible body element.  I've always been
a little bit uncomfortable with the ".. " marker for footnotes because
of this; ".. " has a connotation of "special", but footnotes aren't
especially "special".  Printed texts often put footnotes at the bottom
of the page where the reference occurs (thus "foot note").  Some HTML
designs would leave footnotes to be rendered the same positions where
they're defined.  Other online and printed designs will gather
footnotes into a section near the end of the document, converting them
to "endnotes" (perhaps using a directive in our case); but this
"special processing" is not an intrinsic property of the footnote
itself, but a decision made by the document author or processing
system.</p>
<p>Citations are almost invariably collected in a section at the end of a
document or section.  Citations "disappear" from where they are
defined and are magically reinserted at some well-defined point.
There's more of a connection to the "special" connotation of the ".. "
syntax.  The point at which the list of citations is inserted could be
defined manually by a directive (e.g., ".. citations::"), and/or have
default behavior (e.g., a section automatically inserted at the end of
the document) that might be influenced by options to the Writer.</p>
<p>Syntax proposals:</p>
<ul>
<li><p class="first">Footnotes:</p>
<ul>
<li><p class="first">Current syntax:</p>
<pre class="literal-block">.. [1] Footnote 1
.. [#] Auto-numbered footnote.
.. [#label] Auto-labeled footnote.
</pre>
</li>
<li><p class="first">The syntax proposed in the original 2002-02-28 Doc-SIG post:
remove the ".. ", prefix a "_":</p>
<pre class="literal-block">_[1] Footnote 1
_[#] Auto-numbered footnote.
_[#label] Auto-labeled footnote.
</pre>
<p>The leading underscore syntax (earlier dropped because
<tt class="docutils literal"><span class="pre">..</span> <span class="pre">_[1]:</span></tt> was too verbose) is a useful reminder that footnotes
are hyperlink targets.</p>
</li>
<li><p class="first">Minimal syntax: remove the ".. [" and "]", prefix a "_", and
suffix a ".":</p>
<pre class="literal-block">_1. Footnote 1.
_#. Auto-numbered footnote.
_#label. Auto-labeled footnote.

         ``_1.``, ``_#.``, and ``_#label.`` are markers,
         like list markers.
</pre>
<p>Footnotes could be rendered something like this in HTML</p>
<blockquote>
<p>| 1. This is a footnote.  The brackets could be dropped
|    from the label, and a vertical bar could set them
|    off from the rest of the document in the HTML.</p>
</blockquote>
<p>Two-way hyperlinks on the footnote marker ("1." above) would also
help to differentiate footnotes from enumerated lists.</p>
<p>If converted to endnotes (by a directive/transform), a horizontal
half-line might be used instead.  Page-oriented output formats
would typically use the horizontal line for true footnotes.</p>
</li>
</ul>
</li>
<li><p class="first">Footnote references:</p>
<ul>
<li><p class="first">Current syntax:</p>
<pre class="literal-block">[1]_, [#]_, [#label]_
</pre>
</li>
<li><p class="first">Minimal syntax to match the minimal footnote syntax above:</p>
<pre class="literal-block">1_, #_, #label_
</pre>
<p>As a consequence, pure-numeric hyperlink references would not be
possible; they'd be interpreted as footnote references.</p>
</li>
</ul>
</li>
<li><p class="first">Citation references: no change is proposed from the current footnote
reference syntax:</p>
<pre class="literal-block">[GVR2001]_
</pre>
</li>
<li><p class="first">Citations:</p>
<ul>
<li><p class="first">Current syntax (footnote syntax):</p>
<pre class="literal-block">.. [GVR2001] Python Documentation; van Rossum, Drake, et al.;
   http://www.python.org/doc/
</pre>
</li>
<li><p class="first">Possible new syntax:</p>
<pre class="literal-block">_[GVR2001] Python Documentation; van Rossum, Drake, et al.;
           http://www.python.org/doc/

_[DJG2002]
    Docutils: Python Documentation Utilities project; Goodger
    et al.; http://docutils.sourceforge.net/
</pre>
<p>Without the ".. " marker, subsequent lines would either have to
align as in one of the above, or we'd have to allow loose
alignment (I'd rather not):</p>
<pre class="literal-block">_[GVR2001] Python Documentation; van Rossum, Drake, et al.;
    http://www.python.org/doc/
</pre>
</li>
</ul>
</li>
</ul>
<p>I proposed adopting the "minimal" syntax for footnotes and footnote
references, and adding citations and citation references to
reStructuredText's repertoire.  The current footnote syntax for
citations is better than the alternatives given.</p>
<p>From a reply by Tony Ibbs on 2002-03-01:</p>
<blockquote>
<p>However, I think easier with examples, so let's create one:</p>
<pre class="literal-block">Fans of Terry Pratchett are perhaps more likely to use
footnotes [1]_ in their own writings than other people
[2]_.  Of course, in *general*, one only sees footnotes
in academic or technical writing - it's use in fiction
and letter writing is not normally considered good
style [4]_, particularly in emails (not a medium that
lends itself to footnotes).

.. [1] That is, little bits of referenced text at the
   bottom of the page.
.. [2] Because Terry himself does, of course [3]_.
.. [3] Although he has the distinction of being
   *funny* when he does it, and his fans don't always
   achieve that aim.
.. [4] Presumably because it detracts from linear
   reading of the text - this is, of course, the point.
</pre>
<p>and look at it with the second syntax proposal:</p>
<pre class="literal-block">Fans of Terry Pratchett are perhaps more likely to use
footnotes [1]_ in their own writings than other people
[2]_.  Of course, in *general*, one only sees footnotes
in academic or technical writing - it's use in fiction
and letter writing is not normally considered good
style [4]_, particularly in emails (not a medium that
lends itself to footnotes).

_[1] That is, little bits of referenced text at the
     bottom of the page.
_[2] Because Terry himself does, of course [3]_.
_[3] Although he has the distinction of being
     *funny* when he does it, and his fans don't always
     achieve that aim.
_[4] Presumably because it detracts from linear
     reading of the text - this is, of course, the point.
</pre>
<p>(I note here that if I have gotten the indentation of the
footnotes themselves correct, this is clearly not as nice.  And if
the indentation should be to the left margin instead, I like that
even less).</p>
<p>and the third (new) proposal:</p>
<pre class="literal-block">Fans of Terry Pratchett are perhaps more likely to use
footnotes 1_ in their own writings than other people
2_.  Of course, in *general*, one only sees footnotes
in academic or technical writing - it's use in fiction
and letter writing is not normally considered good
style 4_, particularly in emails (not a medium that
lends itself to footnotes).

_1. That is, little bits of referenced text at the
    bottom of the page.
_2. Because Terry himself does, of course 3_.
_3. Although he has the distinction of being
    *funny* when he does it, and his fans don't always
    achieve that aim.
_4. Presumably because it detracts from linear
    reading of the text - this is, of course, the point.
</pre>
<p>I think I don't, in practice, mind the targets too much (the use
of a dot after the number helps a lot here), but I do have a
problem with the body text, in that I don't naturally separate out
the footnotes as different than the rest of the text - instead I
keep wondering why there are numbers interspered in the text.  The
use of brackets around the numbers ([ and ]) made me somehow parse
the footnote references as "odd" - i.e., not part of the body text
- and thus both easier to skip, and also (paradoxically) easier to
pick out so that I could follow them.</p>
<p>Thus, for the moment (and as always susceptable to argument), I'd
say -1 on the new form of footnote reference (i.e., I much prefer
the existing <tt class="docutils literal"><span class="pre">[1]_</span></tt> over the proposed <tt class="docutils literal"><span class="pre">1_</span></tt>), and ambivalent
over the proposed target change.</p>
<p>That leaves David's problem of wanting to distinguish footnotes
and citations - and the only thing I can propose there is that
footnotes are numeric or # and citations are not (which, as a
human being, I can probably cope with!).</p>
</blockquote>
<p>From a reply by Paul Moore on 2002-03-01:</p>
<blockquote>
<p>I think the current footnote syntax <tt class="docutils literal"><span class="pre">[1]_</span></tt> is <em>exactly</em> the
right balance of distinctness vs unobtrusiveness.  I very
definitely don't think this should change.</p>
<p>On the target change, it doesn't matter much to me.</p>
</blockquote>
<p>From a further reply by Tony Ibbs on 2002-03-01, referring to the
"[1]" form and actual usage in email:</p>
<blockquote>
<p>Clearly this is a form people are used to, and thus we should
consider it strongly (in the same way that the usage of <tt class="docutils literal"><span class="pre">*..*</span></tt>
to mean emphasis was taken partly from email practise).</p>
<p>Equally clearly, there is something "magical" for people in the
use of a similar form (i.e., <tt class="docutils literal"><span class="pre">[1]</span></tt>) for both footnote reference
and footnote target - it seems natural to keep them similar.</p>
<p>...</p>
<p>I think that this established plaintext usage leads me to strongly
believe we should retain square brackets at both ends of a
footnote.  The markup of the reference end (a single trailing
underscore) seems about as minimal as we can get away with.  The
markup of the target end depends on how one envisages the thing -
if ".." means "I am a target" (as I tend to see it), then that's
good, but one can also argue that the "_[1]" syntax has a neat
symmetry with the footnote reference itself, if one wishes (in
which case ".." presumably means "hidden/special" as David seems
to think, which is why one needs a ".." <em>and</em> a leading underline
for hyperlink targets.</p>
</blockquote>
<p>Given the persuading arguments voiced, we'll leave footnote &amp; footnote
reference syntax alone.  Except that these discussions gave rise to
the "auto-symbol footnote" concept, which has been added.  Citations
and citation references have also been added.</p>
</div>
<div class="section" id="auto-enumerated-lists">
<h1><a class="toc-backref" href="#id19" name="auto-enumerated-lists">Auto-Enumerated Lists</a></h1>
<p>The advantage of auto-numbered enumerated lists would be similar to
that of auto-numbered footnotes: lists could be written and rearranged
without having to manually renumber them.  The disadvantages are also
the same: input and output wouldn't match exactly; the markup may be
ugly or confusing (depending on which alternative is chosen).</p>
<ol class="arabic">
<li><p class="first">Use the "#" symbol.  Example:</p>
<pre class="literal-block">#. Item 1.
#. Item 2.
#. Item 3.
</pre>
<p>Advantages: simple, explicit.  Disadvantage: enumeration sequence
cannot be specified (limited to arabic numerals); ugly.</p>
</li>
<li><p class="first">As a variation on #1, first initialize the enumeration sequence?
For example:</p>
<pre class="literal-block">a) Item a.
#) Item b.
#) Item c.
</pre>
<p>Advantages: simple, explicit, any enumeration sequence possible.
Disadvantages: ugly; perhaps confusing with mixed concrete/abstract
enumerators.</p>
</li>
<li><p class="first">Alternative suggested by Fred Bremmer, from experience with MoinMoin:</p>
<pre class="literal-block">1. Item 1.
1. Item 2.
1. Item 3.
</pre>
<p>Advantages: enumeration sequence is explicit (could be multiple
"a." or "(I)" tokens).  Disadvantages: perhaps confusing; otherwise
erroneous input (e.g., a duplicate item "1.") would pass silently,
either causing a problem later in the list (if no blank lines
between items) or creating two lists (with blanks).</p>
<p>Take this input for example:</p>
<pre class="literal-block">1. Item 1.

1. Unintentional duplicate of item 1.

2. Item 2.
</pre>
<p>Currently the parser will produce two list, "1" and "1,2" (no
warnings, because of the presence of blank lines).  Using Fred's
notation, the current behavior is "1,1,2 -&gt; 1 1,2" (without blank
lines between items, it would be "1,1,2 -&gt; 1 [WARNING] 1,2").  What
should the behavior be with auto-numbering?</p>
<p>Fred has produced a <a class="reference" href="http://sourceforge.net/tracker/index.php?func=detail&amp;aid=548802&amp;group_id=38414&amp;atid=422032">patch</a>, whose initial behavior is as follows:</p>
<pre class="literal-block">1,1,1   -&gt; 1,2,3
1,2,2   -&gt; 1,2,3
3,3,3   -&gt; 3,4,5
1,2,2,3 -&gt; 1,2,3 [WARNING] 3
1,1,2   -&gt; 1,2 [WARNING] 2
</pre>
<p>(After the "[WARNING]", the "3" would begin a new list.)</p>
<p>I have mixed feelings about adding this functionality to the spec &amp;
parser.  It would certainly be useful to some users (myself
included; I often have to renumber lists).  Perhaps it's too
clever, asking the parser to guess too much.  What if you <em>do</em> want
three one-item lists in a row, each beginning with "1."?  You'd
have to use empty comments to force breaks.  Also, I question
whether "1,2,2 -&gt; 1,2,3" is optimal behavior.</p>
<p>In response, Fred came up with "a stricter and more explicit rule
[which] would be to only auto-number silently if <em>all</em> the
enumerators of a list were identical".  In that case:</p>
<pre class="literal-block">1,1,1   -&gt; 1,2,3
1,2,2   -&gt; 1,2 [WARNING] 2
3,3,3   -&gt; 3,4,5
1,2,2,3 -&gt; 1,2 [WARNING] 2,3
1,1,2   -&gt; 1,2 [WARNING] 2
</pre>
<p>Should any start-value be allowed ("3,3,3"), or should
auto-numbered lists be limited to begin with ordinal-1 ("1", "A",
"a", "I", or "i")?</p>
</li>
<li><p class="first">Alternative proposed by Tony Ibbs:</p>
<pre class="literal-block">#1. First item.
#3. Aha - I edited this in later.
#2. Second item.
</pre>
<p>The initial proposal required unique enumerators within a list, but
this limits the convenience of a feature of already limited
applicability and convenience.  Not a useful requirement; dropped.</p>
<p>Instead, simply prepend a "#" to a standard list enumerator to
indicate auto-enumeration.  The numbers (or letters) of the
enumerators themselves are not significant, except:</p>
<ul class="simple">
<li>as a sequence indicator (arabic, roman, alphabetic; upper/lower),</li>
<li>and perhaps as a start value (first list item).</li>
</ul>
<p>Advantages: explicit, any enumeration sequence possible.
Disadvantages: a bit ugly.</p>
</li>
</ol>
</div>
<div class="section" id="inline-external-targets">
<h1><a class="toc-backref" href="#id20" name="inline-external-targets">Inline External Targets</a></h1>
<p>Currently reStructuredText has two hyperlink syntax variations:</p>
<ul>
<li><p class="first">Named hyperlinks:</p>
<pre class="literal-block">This is a named reference_ of one word ("reference").  Here is
a `phrase reference`_.  Phrase references may even cross `line
boundaries`_.

.. _reference: http://www.example.org/reference/
.. _phrase reference: http://www.example.org/phrase_reference/
.. _line boundaries: http://www.example.org/line_boundaries/
</pre>
<ul class="simple">
<li>Advantages:<ul class="simple">
<li>The plaintext is readable.</li>
<li>Each target may be reused multiple times (e.g., just write
<tt class="docutils literal"><span class="pre">"reference_"</span></tt> again).</li>
<li>No syncronized ordering of references and targets is necessary.</li>
</ul>
</li>
<li>Disadvantages:<ul class="simple">
<li>The reference text must be repeated as target names; could lead
to mistakes.</li>
<li>The target URLs may be located far from the references, and hard
to find in the plaintext.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">Anonymous hyperlinks (in current reStructuredText):</p>
<pre class="literal-block">This is an anonymous reference__.  Here is an anonymous
`phrase reference`__.  Phrase references may even cross `line
boundaries`__.

__ http://www.example.org/reference/
__ http://www.example.org/phrase_reference/
__ http://www.example.org/line_boundaries/
</pre>
<ul class="simple">
<li>Advantages:<ul class="simple">
<li>The plaintext is readable.</li>
<li>The reference text does not have to be repeated.</li>
</ul>
</li>
<li>Disadvantages:<ul class="simple">
<li>References and targets must be kept in sync.</li>
<li>Targets cannot be reused.</li>
<li>The target URLs may be located far from the references.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>For comparison and historical background, StructuredText also has two
syntaxes for hyperlinks:</p>
<ul>
<li><p class="first">First, <tt class="docutils literal"><span class="pre">"reference</span> <span class="pre">text":URL</span></tt>:</p>
<pre class="literal-block">This is a "reference":http://www.example.org/reference/
of one word ("reference").  Here is a "phrase
reference":http://www.example.org/phrase_reference/.
</pre>
</li>
<li><p class="first">Second, <tt class="docutils literal"><span class="pre">"reference</span> <span class="pre">text",</span> <span class="pre">http://example.com/absolute_URL</span></tt>:</p>
<pre class="literal-block">This is a "reference", http://www.example.org/reference/
of one word ("reference").  Here is a "phrase reference",
http://www.example.org/phrase_reference/.
</pre>
</li>
</ul>
<p>Both syntaxes share advantages and disadvantages:</p>
<ul class="simple">
<li>Advantages:<ul class="simple">
<li>The target is specified immediately adjacent to the reference.</li>
</ul>
</li>
<li>Disadvantages:<ul class="simple">
<li>Poor plaintext readability.</li>
<li>Targets cannot be reused.</li>
<li>Both syntaxes use double quotes, common in ordinary text.</li>
<li>In the first syntax, the URL and the last word are stuck
together, exacerbating the line wrap problem.</li>
<li>The second syntax is too magical; text could easily be written
that way by accident (although only absolute URLs are recognized
here, perhaps because of the potential for ambiguity).</li>
</ul>
</li>
</ul>
<p>A new type of "inline external hyperlink" has been proposed.</p>
<ol class="arabic">
<li><p class="first">On 2002-06-28, Simon Budig <a class="reference" href="http://mail.python.org/pipermail/doc-sig/2002-June/002648.html">proposed</a> a new syntax for
reStructuredText hyperlinks:</p>
<pre class="literal-block">This is a reference_(http://www.example.org/reference/) of one
word ("reference").  Here is a `phrase
reference`_(http://www.example.org/phrase_reference/).  Are
these examples, (single-underscore), named?  If so, `anonymous
references`__(http://www.example.org/anonymous/) using two
underscores would probably be preferable.
</pre>
<p>The syntax, advantages, and disadvantages are similar to those of
StructuredText.</p>
<ul class="simple">
<li>Advantages:<ul class="simple">
<li>The target is specified immediately adjacent to the reference.</li>
</ul>
</li>
<li>Disadvantages:<ul class="simple">
<li>Poor plaintext readability.</li>
<li>Targets cannot be reused (unless named, but the semantics are
unclear).</li>
</ul>
</li>
<li>Problems:<ul class="simple">
<li>The <tt class="docutils literal"><span class="pre">"`ref`_(URL)"</span></tt> syntax forces the last word of the
reference text to be joined to the URL, making a potentially
very long word that can't be wrapped (URLs can be very long). 
The reference and the URL should be separate.  This is a
symptom of the following point:</li>
<li>The syntax produces a single compound construct made up of two
equally important parts, <em>with syntax in the middle</em>, <em>between</em>
the reference and the target.  This is unprecedented in
reStructuredText.</li>
<li>The "inline hyperlink" text is <em>not</em> a named reference (there's
no lookup by name), so it shouldn't look like one.</li>
<li>According to the IETF standards RFC 2396 and RFC 2732,
parentheses are legal URI characters and curly braces are legal
email characters, making their use prohibitively difficult.</li>
<li>The named/anonymous semantics are unclear.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">After an <a class="reference" href="http://mail.python.org/pipermail/doc-sig/2002-July/002670.html">analysis</a> of the syntax of (1) above, we came up with the
following compromise syntax:</p>
<pre class="literal-block">This is an anonymous reference__
__&lt;http://www.example.org/reference/&gt; of one word
("reference").  Here is a `phrase reference`__
__&lt;http://www.example.org/phrase_reference/&gt;.  `Named
references`_ _&lt;http://www.example.org/anonymous/&gt; use single
underscores.
</pre>
<p>The syntax builds on that of the existing "inline internal
targets": <tt class="docutils literal"><span class="pre">an</span> <span class="pre">_`inline</span> <span class="pre">internal</span> <span class="pre">target`.</span></tt></p>
<ul class="simple">
<li>Advantages:<ul class="simple">
<li>The target is specified immediately adjacent to the reference,
improving maintainability:<ul class="simple">
<li>References and targets are easily kept in sync.</li>
<li>The reference text does not have to be repeated.</li>
</ul>
</li>
<li>The construct is executed in two parts: references identical to
existing references, and targets that are new but not too big a
stretch from current syntax.</li>
<li>There's overwhelming precedent for quoting URLs with angle
brackets<a class="footnote-reference" href="#id5" id="id4" name="id4"><sup>1</sup></a>.</li>
</ul>
</li>
<li>Disadvantages:<ul class="simple">
<li>Poor plaintext readability.</li>
<li>Lots of "line noise".</li>
<li>Targets cannot be reused (unless named; see below).</li>
</ul>
</li>
</ul>
<p>To alleviate the readability issue slightly, we could allow the
target to appear later, such as after the end of the sentence:</p>
<pre class="literal-block">This is a named reference__ of one word ("reference").
__&lt;http://www.example.org/reference/&gt;  Here is a `phrase
reference`__.  __&lt;http://www.example.org/phrase_reference/&gt;
</pre>
<p>Problem: this could only work for one reference at a time
(reference/target pairs must be proximate [refA trgA refB trgB],
not interleaved [refA refB trgA trgB] or nested [refA refB trgB
trgA]).  This variation is too problematic; references and inline
external targets will have to be kept imediately adjacent (see (3)
below).</p>
<p>The <tt class="docutils literal"><span class="pre">"reference__</span> <span class="pre">__&lt;target&gt;"</span></tt> syntax is actually for "anonymous
inline external targets", emphasized by the double underscores.  It
follows that single trailing and leading underscores would lead to
<em>implicitly named</em> inline external targets.  This would allow the
reuse of targets by name.  So after <tt class="docutils literal"><span class="pre">"reference_</span> <span class="pre">_&lt;target&gt;"</span></tt>,
another <tt class="docutils literal"><span class="pre">"reference_"</span></tt> would point to the same target.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4" name="id5">[1]</a></td><td><p class="first">From RFC 2396 (URI syntax):</p>
<blockquote>
<p>The angle-bracket "&lt;" and "&gt;" and double-quote (")
characters are excluded [from URIs] because they are often
used as the delimiters around URI in text documents and
protocol fields.</p>
<p>Using &lt;&gt; angle brackets around each URI is especially
recommended as a delimiting style for URI that contain
whitespace.</p>
</blockquote>
<p>From RFC 822 (email headers):</p>
<blockquote class="last">
<p>Angle brackets ("&lt;" and "&gt;") are generally used to indicate
the presence of a one machine-usable reference (e.g.,
delimiting mailboxes), possibly including source-routing to
the machine.</p>
</blockquote>
</td></tr>
</tbody>
</table>
</li>
<li><p class="first">If it is best for references and inline external targets to be
immediately adjacent, then they might as well be integrated.
Here's an alternative syntax embedding the target URL in the
reference:</p>
<pre class="literal-block">This is an anonymous `reference &lt;http://www.example.org
/reference/&gt;`__ of one word ("reference").  Here is a `phrase
reference &lt;http://www.example.org/phrase_reference/&gt;`__.
</pre>
<p>Advantages and disadvantages are similar to those in (2).
Readability is still an issue, but the syntax is a bit less
heavyweight (reduced line noise).  Backquotes are required, even
for one-word references; the target URL is included within the
reference text, forcing a phrase context.</p>
<p>We'll call this variant "embedded URIs".</p>
<p>Problem: how to refer to a title like "HTML Anchors: &lt;a&gt;" (which
ends with an HTML/SGML/XML tag)?  We could either require more
syntax on the target (like <tt class="docutils literal"><span class="pre">"`reference</span> <span class="pre">text</span>
<span class="pre">__&lt;http://example.com/&gt;`__"</span></tt>), or require the odd conflicting
title to be escaped (like <tt class="docutils literal"><span class="pre">"`HTML</span> <span class="pre">Anchors:</span> <span class="pre">\&lt;a&gt;`__"</span></tt>).  The
latter seems preferable, and not too onerous.</p>
<p>Similarly to (2) above, a single trailing underscore would convert
the reference &amp; inline external target from anonymous to implicitly
named, allowing reuse of targets by name.</p>
<p>I think this is the least objectionable of the syntax alternatives.</p>
</li>
</ol>
<p>Other syntax variations have been proposed (by Brett Cannon and Benja
Fallenstein):</p>
<pre class="literal-block">`phrase reference`-&gt;http://www.example.com

`phrase reference`&#64;http://www.example.com

`phrase reference`__ -&gt;http://www.example.com

`phrase reference` [-&gt; http://www.example.com]

`phrase reference`__ [-&gt; http://www.example.com]

`phrase reference` &lt;http://www.example.com&gt;_
</pre>
<p>None of these variations are clearly superior to #3 above.  Some have
problems that exclude their use.</p>
<p>With any kind of inline external target syntax it comes down to the
conflict between maintainability and plaintext readability.  I don't
see a major problem with reStructuredText's maintainability, and I
don't want to sacrifice plaintext readability to "improve" it.</p>
<p>The proponents of inline external targets want them for easily
maintainable web pages.  The arguments go something like this:</p>
<ul>
<li><p class="first">Named hyperlinks are difficult to maintain because the reference
text is duplicated as the target name.</p>
<p>To which I said, "So use anonymous hyperlinks."</p>
</li>
<li><p class="first">Anonymous hyperlinks are difficult to maintain becuase the
references and targets have to be kept in sync.</p>
<p>"So keep the targets close to the references, grouped after each
paragraph.  Maintenance is trivial."</p>
</li>
<li><p class="first">But targets grouped after paragraphs break the flow of text.</p>
<p>"Surely less than URLs embedded in the text!  And if the intent is
to produce web pages, not readable plaintext, then who cares about
the flow of text?"</p>
</li>
</ul>
<p>Many participants have voiced their objections to the proposed syntax:</p>
<blockquote>
<p>Garth Kidd: "I strongly prefer the current way of doing it.
Inline is spectactularly messy, IMHO."</p>
<p>Tony Ibbs: "I vehemently agree... that the inline alternatives
being suggested look messy - there are/were good reasons they've
been taken out...  I don't believe I would gain from the new
syntaxes."</p>
<p>Paul Moore: "I agree as well.  The proposed syntax is far too
punctuation-heavy, and any of the alternatives discussed are
ambiguous or too subtle."</p>
</blockquote>
<p>Others have voiced their support:</p>
<blockquote>
<p>fantasai: "I agree with Simon.  In many cases, though certainly
not in all, I find parenthesizing the url in plain text flows
better than relegating it to a footnote."</p>
<p>Ken Manheimer: "I'd like to weigh in requesting some kind of easy,
direct inline reference link."</p>
</blockquote>
<p>(Interesting that those <em>against</em> the proposal have been using
reStructuredText for a while, and those <em>for</em> the proposal are either
new to the list ["fantasai", background unknown] or longtime
StructuredText users [Ken Manheimer].)</p>
<p>I was initially ambivalent/against the proposed "inline external
targets".  I value reStructuredText's readability very highly, and
although the proposed syntax offers convenience, I don't know if the
convenience is worth the cost in ugliness.  Does the proposed syntax
compromise readability too much, or should the choice be left up to
the author?  Perhaps if the syntax is <em>allowed</em> but its use strongly
<em>discouraged</em>, for aesthetic/readability reasons?</p>
<p>After a great deal of thought and much input from users, I've decided
that there are reasonable use cases for this construct.  The
documentation should strongly caution against its use in most
situations, recommending independent block-level targets instead.
Syntax #3 above ("embedded URIs") will be used.</p>
</div>
<div class="section" id="doctree-representation-of-transitions">
<h1><a class="toc-backref" href="#id21" name="doctree-representation-of-transitions">Doctree Representation of Transitions</a></h1>
<p>(Although not reStructuredText-specific, this section fits best in
this document.)</p>
<p>Having added the "horizontal rule" construct to the <a class="reference" href="reStructuredText.html">reStructuredText
Markup Specification</a>, a decision had to be made as to how to reflect
the construct in the implementation of the document tree.  Given this
source:</p>
<pre class="literal-block">Document
========

Paragraph 1

--------

Paragraph 2
</pre>
<p>The horizontal rule indicates a "transition" (in prose terms) or the
start of a new "division".  Before implementation, the parsed document
tree would be:</p>
<pre class="literal-block">&lt;document&gt;
    &lt;section name="document"&gt;
        &lt;title&gt;
            Document
        &lt;paragraph&gt;
            Paragraph 1
        --------               &lt;--- error here
        &lt;paragraph&gt;
            Paragraph 2
</pre>
<p>There are several possibilities for the implementation:</p>
<ol class="arabic">
<li><p class="first">Implement horizontal rules as "divisions" or segments.  A
"division" is a title-less, non-hierarchical section.  The first
try at an implementation looked like this:</p>
<pre class="literal-block">&lt;document&gt;
    &lt;section name="document"&gt;
        &lt;title&gt;
            Document
        &lt;paragraph&gt;
            Paragraph 1
        &lt;division&gt;
            &lt;paragraph&gt;
                Paragraph 2
</pre>
<p>But the two paragraphs are really at the same level; they shouldn't
appear to be at different levels.  There's really an invisible
"first division".  The horizontal rule splits the document body
into two segments, which should be treated uniformly.</p>
</li>
<li><p class="first">Treating "divisions" uniformly brings us to the second
possibility:</p>
<pre class="literal-block">&lt;document&gt;
    &lt;section name="document"&gt;
        &lt;title&gt;
            Document
        &lt;division&gt;
            &lt;paragraph&gt;
                Paragraph 1
        &lt;division&gt;
            &lt;paragraph&gt;
                Paragraph 2
</pre>
<p>With this change, documents and sections will directly contain
divisions and sections, but not body elements.  Only divisions will
directly contain body elements.  Even without a horizontal rule
anywhere, the body elements of a document or section would be
contained within a division element.  This makes the document tree
deeper.  This is similar to the way <a class="reference" href="http://www.w3.org/MarkUp/">HTML</a> treats document contents:
grouped within a <tt class="docutils literal"><span class="pre">&lt;body&gt;</span></tt> element.</p>
</li>
<li><p class="first">Implement them as "transitions", empty elements:</p>
<pre class="literal-block">&lt;document&gt;
    &lt;section name="document"&gt;
        &lt;title&gt;
            Document
        &lt;paragraph&gt;
            Paragraph 1
        &lt;transition&gt;
        &lt;paragraph&gt;
            Paragraph 2
</pre>
<p>A transition would be a "point element", not containing anything,
only identifying a point within the document structure.  This keeps
the document tree flatter, but the idea of a "point element" like
"transition" smells bad.  A transition isn't a thing itself, it's
the space between two divisions.  However, transitions are a
practical solution.</p>
</li>
</ol>
<p>Solution 3 was chosen for incorporation into the document tree model.</p>
<!-- Local Variables:
mode: indented-text
indent-tabs-mode: nil
sentence-end-double-space: t
fill-column: 70
End: -->
</div>
</div>
</body>
</html>
