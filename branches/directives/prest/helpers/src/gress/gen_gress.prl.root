#!/usr/local/bin/perl

=pod
=for reST
=begin Id
$Id: gen_gress.prl.root,v 1.3 2005/04/08 19:36:02 nodine Exp $
Copyright (C) 2002-2005 Freescale Semiconductor, Inc.
Distributed under terms of the GNU General Public License (GPL).
=end Id

=begin Description
Description: This program generates a .sh file from a .job file 
with a list of tests and commands to execute for each test in the suite.
Here is the format of the .job file.  Each line has one of the following
formats:
  '= ' <suite title text>
  '+ ' <passing test title>
  '- ' <error test title>
  <any other text>
These get processed as follows.  
  '= ' lines get turned into a banner announcing the test suite.  There
       can be more than one of them.
  '+ ' lines get turned into banners wrapping the output of a test that
       is expected to pass.
  '- ' lines get turned into banners wrapping the output of a test that
       is expected to return an error.
  <any other text> represent shell commands that get run at their point
       in the file.  Shell commands can be placed before the first
       '+ ' or '- ' to do initialization required for all the tests.
       Any other shell commands are associated with the immediately
       preceding '+ ' or '- ' test.

=end Description
=begin Usage
Usage: ${main::TOOL_NAME} [options] file

Options:
  -h       Print help
  -i dir   Subdirectory to check for test-specific data files (default
           '<opt_s_dir>.init')
  -p path  Path of external directories to allow while running test
           (default '')
  -s dir   Subdirectory in which to run the tests (default 'rundir')
  -V       Print version
=end Usage
=cut

use Getopt::Std;

$0 =~ m|([^\/]+)$|;
$main::TOOL_NAME = $1;

main();

sub main {
    $opt_s = "rundir";
#    $opt_p = '${PATH}';
    Usage() unless getopts("hi:p:s:V");
    Usage('Id') if $opt_V;
    Usage('Description') if $opt_h;
    $opt_i = "$opt_s.init" unless defined $opt_i;

    my $header = join('',<DATA>);
    $header =~ s/(\$\{[^\}]+\})/eval($1)/ge;
    print $header;
    while (<>) {
	if (/^= (.*)/) {
	    print @code if @code;
	    @code = ();
	    print qq|echo "#**************************"
echo "# START  $1"
echo "#**************************"
echo\n\n|;
	}
	elsif (/^(([+-]) .*)/) {
	    $new_string = $2 eq "+" ? "$1 good" : "$1--should error";
	    print @code if @code;
	    @code = ();
	    print qq|echo "# END   $string"\necho ""\n\n|
		if $string;
	    $string = $new_string;
	    print qq|echo "# START $string"\n|;
	}
	elsif (! /^\s+$/) {
	    push(@code, $_);
	}
    }
    if ($string) {
	print @code,qq|echo "# END   $string"\necho ""\n\n|;
    }
    else {
	print @code;
    }
}

# This subroutine extracts and prints usage information
sub Usage {
    my ($what) = @_;
    $what = "Usage" if ! $what;
    my $mark = $what eq 'Description' ? "($what|Usage)" : $what;
    if (open(ME,$0) == 1) {
	while (<ME>) {
	    if ((/^=begin $mark/ .. /^=end $mark/) &&
		! /^=(begin|end) $mark/) {
		s/(\$\{[^\}]+\})/eval($1)/ge;
		print;
	    }
	}
	close(ME);
    }
    else {
	print STDERR "Usage not available.\n";
    }
    exit (1);
}

__END__
#!/bin/sh
						
#--------
# restricted paths for security
#--------

# Parse options:
#   -h <path>     High priority run-time path

while getopts h: c
do
   case $c in
    h)     PATH_H=$OPTARG
   esac
done

# Use relative path so script will work in different people's repositories

PATH_REQ=${PATH_REQ}
PATH=$PATH_H:.:../../../../bin:../../../bin:../../../../src:../../../src:${opt_p}:$PATH_REQ
export PATH

cd `dirname $0`

# --------------------
# Clean up the initial test data directory
# --------------------

echo "# Purging old ${opt_s} directory"

if [ -d ${opt_s} ]
then
    chmod -R 777 ${opt_s}
    rm -rf ${opt_s}
fi


mkdir ${opt_s}

# --------------------
# Seed the test area with initial data
# --------------------
if [ -d init ]
then
    echo "# Unpacking data from init"
    (cd init; find . -type f -depth | egrep -v '/(CVS|RCS|\.svn)' | cpio -pumd ../${opt_s}) > /dev/null 2>&1
fi

if [ -d ${opt_i} ]
then
    echo "# Unpacking data from ${opt_i}"
    (cd ${opt_i}; find . -type f -depth | egrep -v '/(CVS|RCS|\.svn)' | cpio -pumd ../${opt_s}) > /dev/null 2>&1
fi

cd ${opt_s}
