==================================
 Support for Multiple Input Files
==================================

:Author: Lea Wiemann <LeWiemann@gmail.com>
:Date: $Date$
:Revision: $Revision$
:Copyright: This document has been placed in the public domain.

.. contents::


Introduction
============

We would like to support documents whose source text comes from
multiple files.  For instance, the Docutils documentation tree could
be considered a large document; parsing all files into one single
document tree would enable us to do cross-linking between parts of the
documentation (our current way to cross-link between files is to link
to HTML files and fragments, which is a hack).

Note that this issue is separate from output to multiple files; after
implementing support for multiple input files, all we will be able to
do is to generate a huge single output file.

This is a collection of notes and semi-random thoughts (many of which
are credit to David, from IM conversations).  Feel free to add yours!


Terminology
===========

Right now, we are using the foloowing terminology: The whole document
is simply called *the document*.  Its input consists of multiple
*files*: A *master* file (which references the sub-documents), and
*sub-document* files.  The sub-document files should (probably) each
be processable stand-alone (without the other files), each forming a
document on its own.

Should we say "book" instead of "document"?  Is "file" confusing
(physical vs. logical entity?); should be use "sub-document" instead?


The ``subdocument`` Directive
=============================

* The "include" directive is not usable for this because we want to
  have independent parsing contexts (for instance, section title
  adornment should not have to be consistent across input files).

* So create a "subdocument" directive (syntax: ".. subdocument::
  file.txt").  This directive causes the referenced file to be parsed
  and its document tree to be inserted in place.

  - The sub-document must have a document title.  (This document title
    will become a section title.)
    
  - The subdocument directive should be treated like a section; that
    is, no elements except for more sections or transitions may
    follow.
    
  - In order to facilitate assembling a large number of hierarchical
    files into a large document, the subdocument directive should
    allow specifying any number of files, like this::

        .. subdocument::

           chapter1.txt
               chapter1-section1.txt
               chapter1-section2.txt
           chapter2.txt
               chapter2-section1.txt
               ...

    Specifying an indented file (like chapter1-section1.txt) is
    equivalent to inserting ".. subdocument:: chapter1-section1.txt"
    at the end of chapter1.txt.

    Lists of files should be required to be directive content, not
    parameters, because file lists as parameters would be prone to
    uncaught user errors.  In this example, the indentation of
    "chapter1-section1.txt" would be stripped by the directive parser,
    which is contrary to what the user expects::

        .. subdocument:: chapter1.txt
               chapter1-section1.txt

* What do we do with docinfos in subdocuments?

  - Allow for section infos by generalizing the existing docinfo node.

  - Add an option to either strip or leave docinfos.  Perhaps
    specifiable as an option to the "subdocument" directive, and/or on
    a per-input-file basis (how?), and/or as a command line option.
    (Applied in which order?)

  - Should there also be a way to have per-section section infos in
    reStructuredText files, as opposed to just file-wide docinfos?  If
    not, the only way to get section infos in a document is to use
    sub-documents (which might be fine).

  - For a first implementation, just go the easy route and strip all
    docinfos in sub-documents.

* In order to facilitate multi-file output that parallels the input
  file structure, add "source" attributes to section nodes for
  sections that come from different input files.

* Allow multiple top-level sections in sub-documents.  (No reason not
  to; the implementation doesn't get much harder.)  Sub-documents can
  therefore contain either a lone document title (and optionally a
  docinfo), or multiple top-level sections.  Only support per-document
  docinfos -- if a sub-document contains multiple top-level sections,
  don't touch field lists at all.

* Restriction: Do not allow sub-documents without a top-level section,
  or with body elements in front of the first section.  IOW, the
  sub-document may only contain PreBibliographic elements, sections,
  and transitions.  The PreBibliographic elements in front of the
  first section get moved into the section.

  David says this restriction is bad and we probably shouldn't have it
  -- for instance you might want to have an introductory paragraph in
  front of the first section of the first sub-document; Lea doesn't
  mind the restriction and says you could use the "include" directive.
  Since having the restriction makes the implementation somewhat
  easier, we agreed on having this restriction, waiting until the
  first user presents a good use case to remove it, and calling it a
  YAGNI until then.

* Silently drop header and footer in sub-documents.  (Document this in
  directives.txt though.)

* To do: Explore alternatives besides "subdocument" for the directive
  name.

* You may want to read some insightful remarks by Joaquim Baptista on
  how `files should be expected to be part of different documents`__.

  .. _different documents:
  __ http://article.gmane.org/gmane.text.docutils.devel/4043


.. _xrefs:

Cross-references
================

.. note:: You may need to read the `reST spec`_ in order to understand
   the terminology (targets, references).  In this section, "*external
   reference*" means a reference whose target is outside of the
   current file, but within the current document.

   .. _reST spec: http://docutils.sf.net/docs/ref/rst/restructuredtext.html

A major issue to think about is how to do **cross-references**
(colloquially known as **xrefs**) between files.  Things like
substitutions or role definitions should not be shared between files
(their definitions can simply be loaded using the "include"
directive).  However, sharing targets and thereby allowing
cross-references between files is one of the major points why we want
an architecture that supports multiple input files.

Issues arise once we think about how to group target names into
namespaces.  Unfortunately, simply putting all targets into a global,
document-wide namespace is bound to cause collisions; files that were
processable stand-alone are no longer processable when used in
conjunction with other files because they share common target names.


Bad Proposal: Local and Global Namespace, no Qualifiers
-------------------------------------------------------

An obvious solution would be to add a notion of a file-local and a
global namespace.  When trying to resolve a reference, first the
target name is looked up in the local namespace of the current file;
if no suitable target is found there, the target name is searched for
document-wide, in the global namespace; if the target name exists and
is unique within the document, the reference can be resolved.

If references to the global namespace are not marked up as such,
however, the individual files are no longer processable stand-alone
because they contain unresolvable references.  While it is to be
expected that external cross-references may not (fully) work any
longer when a file is processed stand-alone, it would be nice to be
able to handle unresolved external references somehow, rather than
simply throwing an error. (XXX explain why we really want this a) for
authoring and b) for processing files individually in a
compiler-linker like fashion. For point b, briefly talk about
target->ID mapping files [databases].)

This can be solved by marking external references as such, like this::

    `local target name`_
    `-> global target name`_

where "local target name" must be a unique target name within the
current file, and "global target name" must be a unique target name
within the current document.

.. We would need to explicitly establish a notion of "stand-alone" vs.
   "full document" processing in this case, but this proposal is being
   shot down anyway, so I'm not going to get into it.

This approach turns out to have a major drawback though: External
references depend on the context of the containing document.  However,
as Joaquim `pointed out`__, files should be expected to be part of
several documents.  This means that once a file is put into the
context of a new document, its external references might point to
non-existing or duplicate targets.  This seems like a maintenance
problem for complex (large) collections of documentation.

__ different documents_

Another peculiarity of this system is that an external reference is
not associated to the file that defines the target outside of a
document context.  This brings the advantage that renaming and moving
files won't invalidate reference names.  On the downside, it lacks
clarity for the reader because the file containing a target is often
not inferable from the target name (try to guess which file ```->
html4css1`_`` links to) -- this may be significant since
reStructuredText should be readable in its source form.


Proposal: Explicit Qualifiers
-----------------------------

Since linking to targets outside the scope of the current document
appears to be a bad idea, we may need some form of qualifiers.

Namespace Identifiers
~~~~~~~~~~~~~~~~~~~~~

This makes it necessary to add a notion of *namespace identifiers*.

.. sidebar:: Why headers are a bad idea

   One of the appealing features of reStructuredText, compared to
   LaTeX, is that writing a document does not require writing a
   header.  Just type the title, some text, run rst2html, and you're
   done.  Writing a stand-alone LaTeX document on the other hand
   typically begins with declaring the \\documentclass, loading all
   the packages you need for your document, setting some options, and
   finally \\begin{document}.

   While it may not be possible to go *entirely* without any explicit
   markup, it is certainly a worthwhile goal to keep the amount of
   such markup to a minimum.

It is possible to always name the namespace of the current file (as it
is done in C++).  For instance, "``.. namespace:: frob``" at the
beginning of a file could declare that the namespace of the current
file is called "frob".  However, this is a little verbose as it adds a
line at the top of each file (see the sidebar).

Qualifier Syntax
~~~~~~~~~~~~~~~~

Note that in all of these examples, the reference text of the inline
reference (like ```<namespace> target`_``) comes out as "target",
i.e. the namespace identifier and the decoration or separator are
stripped.

* Angled brackets::

      `<namespace> target`_
      .. _reference: <namespace> target_

  This is similar to the syntax for embedded URI's (```target
  <URI>`_``).  It fits well into the existing syntax, but may be
  confusing at the same time.

* Arrows::

      `namespace -> target`_
      .. _reference: namespace -> target_

  In case of "imported" namespaces (analogously to C++'s "using
  namespace" keyword), this would also allow for namespace-less
  references; for instance, after ".. import:: namespace" it would be
  possible to write::

      `-> target`_

  The syntax may collide with existing target names.  (Perhaps we
  could give existing targets name priority though?  I.e., the
  reference resolver checks whether "foo -> bar" is a valid local
  target name before looking up target "bar" in namespace "foo".)

  Alternatives for the arrow: ``-->``, or ``>>``.

  Should there we whitespace around the arrow (yes/no/optional)?  It
  looks more readable with whitespace, but omitting the whitespace
  makes it terser.

* HTML fragment identifier syntax::

      `namespace#target`_
      .. _reference: namespace#target_

  This is probably a bad idea since it easily gets confused with
  relative URIs::

      .. _reference1: spec.html#target  (<--- URI)
      .. _reference2: spec#target_      (<--- external target)

  This is especially bothersome in cases such as Docutils' own
  documentation tree, where we would want to refactor targets
  referring to relative URI's into indirect targets cross-referencing
  targets in other documents (so ``config.html#foo`` becomes
  ``config#foo_``); visually distinguishing between old-style and
  new-style targets is important, and a qualifier syntax paralleling
  HTML's fragment identifier makes this hard.

----------------------------------------------------------------------

XXX TODO:

- How to derive namespace names.
- Why we need the notion of a *project root* for namespace names
  derived from paths and file names, and how to find the root.
- Syntax alternatives for shortening namespace identifiers
  (e.g. ``.. external-targets:: config = docs/user/config.txt``)
- Explore how to avoid spreading path names all over the document
  (maintenance issue?).
- Explore relative vs. absolute path references (mutually
  exclusive!).
- Name some advantages (explicitness, more?) and disadvantages
  (verbosity, complexity).
