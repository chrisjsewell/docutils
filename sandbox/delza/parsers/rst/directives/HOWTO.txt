How to create a new directive
=============================

Since creating directives is one of the primary extension mechanisms of
|reST|, it's worth making as easy and understandable as possible. There are
only a couple of reST-specific features you need to know to create a basic
directive.

.. contents:: Table of Contents

Define Directive
----------------

The directive signature itself should follow this template:

    def my_directive(match, type_name, data, state, state_machine, option_presets):
       """
       Parameters:

       - `match`, `type_name`, `state`, `state_machine`, and `option_presets`: See
         `docutils.parsers.rst.directives.__init__`.

       Returns a list of |reST| elements
       """

Define Options
--------------

You will have to define the options your directive requires.  This is a
dictionary of name, conversion pairs which are applied to each option value to
convert it to an expected type.  Python's built-in conversion are often usable
for this, for example, str, int, float.  Other useful types would be bool
(included in python 1.3) and exists (to test for existence of an option when
you don't care about the value or the option has no value).

Parse Directive
---------------

You'll want to use the parse_directive method, which has returns a 4-tuple
(arguments, options, content, blank_finish) and has the following signature:

    def parse_directive(match, type_name, state, state_machine,
                        option_presets, arguments=None,
                        option_spec={}, content=None):

        """
        Parameters:

        - `match`, `type_name`, state`, `state_machine`, and
          `option_presets`: See `docutils.parsers.rst.directives.__init__`.
        - `arguments`: A 2-tuple of the number of ``(required,
          optional)`` whitespace-separated arguments to parse, or
          ``None`` if no arguments (same as ``(0, 0)``).  If an
          argument may contain whitespace (multiple words), specify
          only one argument (either required or optional); the client
          code must do any context-sensitive parsing.
        - `option_spec`: A dictionary, mapping known option names to
          conversion functions such as `int` or `float`.  ``None`` or
          an empty dict implies no options to parse.
        - `content`: A boolean; true if content is allowed.  Client
          code must handle the case where content is required but not
          supplied (an empty content list will be returned).

        Returns a 4-tuple: list of arguments, dict of options, list of
        strings (content block), and a boolean (blank finish).

        Or raises `DirectiveParseError` with arguments: node (system
        message), boolean (blank finish).
        """

Directive-Specific Validation
-----------------------------

Once you have the return value from parse_directive, you will want to do some
directive-specific data validation, to make sure what is returned matches what
you were expecting.

Usually, this will involve calling rest_assert(bool, string) and trapping the
result thrown, which will be a |reST| error element.  You may need to manually
test parse results to make sure you receive a valid number of options, and to
decide which assertions to make.  See the examples below for more.

Directive-Specific Processing
-----------------------------

Any additional processing that your directive requires, which may or may not
require other parts of reST.  This is the area where you actually make your
directive *do* something.  What it does here is up to you.

Return Values
-------------

Finally, create and return a list of appropriate reST elements.  Directives
have no corresponding element, so you will need to determine which of the
existing elements is most appropriate.

Register Directive
------------------

Register your new directive in directives/__init__.py.  This allows the |reST|
system to find and use your directive.


Examples
--------

Raw Directive
.............

Include Directive
.................

Replace Directive
.................


.. |reST| replace:: reStructured Text
