# Author: Edward Loper
# Contact: edloper@gradient.cis.upenn.edu
# Revision: $Revision$
# Date: $Date$
# Copyright: This module has been placed in the public domain.

"""
This module defines a registry for interpreted roles.

The interface for interpreted role functions is as follows::

    def role_fn(name, rawtext, text, lineno, inliner):
        code...

Parameters:
    
- ``name`` is the interpreted role type or name.

- ``rawtext`` is a string containing the entire interpreted text.
  Include it as the content of a system message if there is a
  problem.

- ``text`` is the interpreted text content.

- ``lineno`` is the line number where the interpreted text beings.

- ``inliner`` is the Inliner object that called the role function.
  It defines the following useful attributes: ``reporter``,
  ``problematic``, ``memo``, ``parent``, ``document``.

Interpreted role functions return a tuple of two values:

- A list of nodes which will be inserted into the document tree at the
  point where the interpreted role was encountered (can be an empty
  list).

- A list of messages, which will be inserted into the document tree
  immediately after the end of the current inline block.
"""

__docformat__ = 'reStructuredText'

from docutils import nodes
from docutils.parsers.rst.languages import en as _fallback_language_module

_roles = {}
"""
The interpreted role registry.  This registry map canonical role names
to role functions.  Language-dependent role names are defined in the
``language`` subpackage.
"""

def role(role_name, language_module, lineno, inliner):
    """
    Locate and return a role function from its language-dependent
    name.  If not found in the current language, check English.
    Return None if the named role cannot be found.
    """
    normname = role_name.lower()
    messages = []
    msg_text = []

    canonicalname = None
    try:
        canonicalname = language_module.roles[normname]
    except AttributeError, error:
        msg_text.append('Problem retrieving role entry from language '
                        'module %r: %s.' % (language_module, error))
    except KeyError:
        msg_text.append('No role entry for "%s" in module "%s".'
                        % (role_name, language_module.__name__))

    # If we didn't find it, try english as a fallback.
    if not canonicalname:
        try:
            canonicalname = _fallback_language_module.roles[normname]
            msg_text.append('Using English fallback for role "%s".'
                            % role_name)
        except KeyError:
            msg_text.append('Trying "%s" as canonical role name.'
                            % role_name)
            # The canonical name should be an English name, but just in case:
            canonicalname = normname

    # Collect any messages that we generated.
    if msg_text:
        message = inliner.reporter.info('\n'.join(msg_text), line=lineno)
        messages.append(message)
        
    # Look the role up in the registry, and return it.
    if _roles.has_key(canonicalname):
        return _roles[canonicalname], messages
    else:
        return None, messages # Error message will be generated by caller.
    
def register_role(name, role_fn):
    """
    Register an interpreted role.
    
    :Parameters:
      - `name`: The canonical name of the interpreted role.
      - `role_fn`: The role function.  See the module docstring for
        `docutils.parsers.rst.roles` for a description of the
        signature for `role_fn`.
    """
    _roles[name] = role_fn

######################################################################
# What's the default interpreted role?
######################################################################

DEFAULT_INTERPRETED_ROLE = 'title-reference'

######################################################################
# Create and register the standard roles:
######################################################################

def make_generic_role(node_class, role, rawtext, text, lineno, inliner):
    # If we wanted to, we could recursively call inliner.nested_parse
    # to interpret the text contents here (after appropriately
    # refactoring Inliner.parse).
    return [node_class(rawtext, text)], []

def abbreviation_role(*args):
    return make_generic_role(nodes.abbreviation, *args)
register_role('abbreviation', abbreviation_role)

def acronym_role(*args):
    return make_generic_role(nodes.acronym, *args)
register_role('acronym', acronym_role)

def emphasis_role(*args):
    return make_generic_role(nodes.emphasis, *args)
register_role('emphasis', emphasis_role)

def literal_role(*args):
    return make_generic_role(nodes.literal, *args)
register_role('literal', literal_role)

def strong_role(*args):
    return make_generic_role(nodes.strong, *args)
register_role('strong', strong_role)

def subscript_role(*args):
    return make_generic_role(nodes.subscript, *args)
register_role('subscript', subscript_role)

def superscript_role(*args):
    return make_generic_role(nodes.superscript, *args)
register_role('superscript', superscript_role)

def title_reference_role(*args):
    return make_generic_role(nodes.title_reference, *args)
register_role('title-reference', title_reference_role)

def pep_reference_role(role, rawtext, text, lineno, inliner):
    try:
        pepnum = int(text)
        if pepnum < 0 or pepnum > 9999:
            raise ValueError
    except ValueError:
        msg = inliner.reporter.error(
            'PEP number must be a number from 0 to 9999; "%s" is invalid.'
            % text, line=lineno)
        prb = inliner.problematic(text, text, msg)
        return [prb], [msg]
    ref = inliner.pep_url % pepnum # [XX]
    return [nodes.reference(rawtext, 'PEP ' + text, refuri=ref)], []
register_role('pep-reference', pep_reference_role)
    
def rfc_reference_role(role, rawtext, text, lineno, inliner):
    try:
        rfcnum = int(text)
        if rfcnum <= 0:
            raise ValueError
    except ValueError:
        msg = inliner.reporter.error(
            'RFC number must be a number greater than or equal to 1; '
            '"%s" is invalid.' % text, line=lineno)
        prb = inliner.problematic(text, text, msg)
        return [prb], [msg]
    ref = inliner.rfc_url % rfcnum # [XX]
    return [nodes.reference(rawtext, 'RFC ' + text, refuri=ref)], []
register_role('rfc-reference', rfc_reference_role)

######################################################################
# Register roles that are currently unimplemented.
######################################################################

def unimplemented_role(role, rawtext, text, lineno, inliner):
    msg = inliner.reporter.error(
        'Interpreted text role %r not implemented.' % role, line=lineno)
    prb = inliner.problematic(rawtext, rawtext, msg)
    return [prb], [msg]

register_role('index', unimplemented_role)
register_role('named-reference', unimplemented_role)
register_role('anonymous-reference', unimplemented_role)
register_role('uri-reference', unimplemented_role)
register_role('pep-reference', unimplemented_role)
register_role('rfc-reference', unimplemented_role)
register_role('footnote-reference', unimplemented_role)
register_role('citation-reference', unimplemented_role)
register_role('substitution-reference', unimplemented_role)
register_role('target', unimplemented_role)
register_role('restructuredtext-unimplemented-role', unimplemented_role)
